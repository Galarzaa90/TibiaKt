


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > CharacterParser</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">com.galarzaa.tibiakt.core.parsers</a>
</div>

<h1>Coverage Summary for Class: CharacterParser (com.galarzaa.tibiakt.core.parsers)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
<th class="coverageStat 
">
  Instruction, %
</th>
</tr>
<tr>
  <td class="name">CharacterParser</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (13/13)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    71.5%
  </span>
  <span class="absValue">
    (118/165)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    97.3%
  </span>
  <span class="absValue">
    (145/149)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    92.3%
  </span>
  <span class="absValue">
    (1300/1408)
  </span>
</td>
</tr>
  <tr>
    <td class="name">CharacterParser$parseCharacterDeaths$1$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
    <td class="coverageStat"/>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (14/14)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    71.5%
  </span>
  <span class="absValue">
    (118/165)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    97.3%
  </span>
  <span class="absValue">
    (146/150)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    92.3%
  </span>
  <span class="absValue">
    (1302/1410)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright Â© 2023 Allan Galarza
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;
&nbsp;package com.galarzaa.tibiakt.core.parsers
&nbsp;
&nbsp;import com.galarzaa.tibiakt.core.builders.CharacterBuilder
&nbsp;import com.galarzaa.tibiakt.core.builders.character
&nbsp;import com.galarzaa.tibiakt.core.enums.StringEnum
&nbsp;import com.galarzaa.tibiakt.core.exceptions.ParsingException
&nbsp;import com.galarzaa.tibiakt.core.models.character.Character
&nbsp;import com.galarzaa.tibiakt.core.models.character.Killer
&nbsp;import com.galarzaa.tibiakt.core.utils.clean
&nbsp;import com.galarzaa.tibiakt.core.utils.getLinkInformation
&nbsp;import com.galarzaa.tibiakt.core.utils.parsePopup
&nbsp;import com.galarzaa.tibiakt.core.utils.parseTables
&nbsp;import com.galarzaa.tibiakt.core.utils.parseTibiaDate
&nbsp;import com.galarzaa.tibiakt.core.utils.parseTibiaDateTime
&nbsp;import com.galarzaa.tibiakt.core.utils.remove
&nbsp;import com.galarzaa.tibiakt.core.utils.splitList
&nbsp;import kotlinx.datetime.Instant
&nbsp;import org.jsoup.Jsoup
&nbsp;import org.jsoup.nodes.Document
&nbsp;import org.jsoup.nodes.Element
&nbsp;import org.jsoup.select.Elements
&nbsp;
&nbsp;/** Parser for character information pages. */
&nbsp;public object CharacterParser : Parser&lt;Character?&gt; {
<b class="fc">&nbsp;    private val deletedRegexp = Regex(&quot;&quot;&quot;([^,]+), will be deleted at (.*)&quot;&quot;&quot;)</b>
<b class="fc">&nbsp;    private val titlesRegexp = Regex(&quot;&quot;&quot;(.*)\((\d+) titles? unlocked\)&quot;&quot;&quot;)</b>
<b class="fc">&nbsp;    private val houseRegexp = Regex(&quot;&quot;&quot;\(([^)]+)\) is paid until (.*)&quot;&quot;&quot;)</b>
<b class="fc">&nbsp;    private val deathsRegex = Regex(&quot;&quot;&quot;Level (\d+) by (.*)\.&lt;/td&gt;&quot;&quot;&quot;)</b>
<b class="fc">&nbsp;    private val deathAssistsRegex = Regex(&quot;&quot;&quot;(?:(?&lt;killers&gt;.+)\.&lt;br\s?/&gt;)?Assisted by (?&lt;assists&gt;.+)&quot;&quot;&quot;)</b>
<b class="fc">&nbsp;    private val linkSearch = Regex(&quot;&quot;&quot;&lt;a[^&gt;]+&gt;[^&lt;]+&lt;/a&gt;&quot;&quot;&quot;)</b>
<b class="fc">&nbsp;    private val linkContent = Regex(&quot;&quot;&quot;&gt;([^&lt;]+)&lt;&quot;&quot;&quot;)</b>
<b class="fc">&nbsp;    private val deathSummon = Regex(&quot;&quot;&quot;(?&lt;summon&gt;an? .+) of (?&lt;name&gt;.*)&quot;&quot;&quot;)</b>
&nbsp;    private const val tradedLabel = &quot;(traded)&quot;
&nbsp;
&nbsp;    override fun fromContent(content: String): Character? {
<b class="fc">&nbsp;        val document: Document = Jsoup.parse(content, &quot;&quot;, org.jsoup.parser.Parser.xmlParser())</b>
<b class="fc">&nbsp;        val boxContent =</b>
<b class="pc">&nbsp;            document.selectFirst(&quot;div.BoxContent&quot;) ?: throw ParsingException(&quot;BoxContent container not found&quot;)</b>
<b class="fc">&nbsp;        val tables = boxContent.parseTables()</b>
<b class="pc">&nbsp;        if (tables.keys.any { it.startsWith(&quot;Could not find character&quot;) }) return null</b>
<b class="fc">&nbsp;        return character {</b>
<b class="fc">&nbsp;            parseCharacterInformation(tables[&quot;Character Information&quot;] ?: return null)</b>
<b class="fc">&nbsp;            tables[&quot;Account Badges&quot;]?.apply { parseAccountBadges(this) }</b>
<b class="pc">&nbsp;            tables[&quot;Account Achievements&quot;]?.apply { parseAccountAchievements(this) }</b>
<b class="fc">&nbsp;            tables[&quot;Account Information&quot;]?.apply { parseAccountInformation(this) }</b>
<b class="fc">&nbsp;            tables[&quot;Character Deaths&quot;]?.apply { parseCharacterDeaths(this) }</b>
<b class="fc">&nbsp;            tables[&quot;Characters&quot;]?.apply { parseCharacters(this) }</b>
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    private fun CharacterBuilder.parseCharacterInformation(rows: Elements) {
<b class="fc">&nbsp;        for (row: Element in rows) {</b>
<b class="fc">&nbsp;            val columns = row.select(&quot;td&quot;)</b>
<b class="fc">&nbsp;            var (field, value) = columns.map { it.wholeText().clean() }</b>
<b class="fc">&nbsp;            field = field.replace(&quot; &quot;, &quot;_&quot;).remove(&quot;:&quot;).lowercase()</b>
<b class="pc">&nbsp;            when (field) {</b>
<b class="fc">&nbsp;                &quot;name&quot; -&gt; parseNameField(value)</b>
<b class="fc">&nbsp;                &quot;title&quot; -&gt; parseTitles(value)</b>
<b class="fc">&nbsp;                &quot;former_names&quot; -&gt; formerNames = value.split(&quot;,&quot;).map { it.trim() }</b>
<b class="fc">&nbsp;                &quot;former_world&quot; -&gt; formerWorld = value</b>
<b class="fc">&nbsp;                &quot;sex&quot; -&gt; sex = StringEnum.fromValue(value)!!</b>
<b class="fc">&nbsp;                &quot;vocation&quot; -&gt; vocation =</b>
<b class="pc">&nbsp;                    StringEnum.fromValue(value) ?: throw ParsingException(&quot;Unknown vocation: $value&quot;)</b>
&nbsp;
<b class="fc">&nbsp;                &quot;level&quot; -&gt; level = value.toInt()</b>
<b class="fc">&nbsp;                &quot;achievement_points&quot; -&gt; achievementPoints = value.toInt()</b>
<b class="fc">&nbsp;                &quot;world&quot; -&gt; world = value</b>
<b class="fc">&nbsp;                &quot;residence&quot; -&gt; residence = value</b>
<b class="pc">&nbsp;                &quot;last_login&quot; -&gt; if (!value.contains(&quot;never logged&quot;, true)) {</b>
<b class="fc">&nbsp;                    lastLogin = parseTibiaDateTime(value)</b>
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                &quot;position&quot; -&gt; position = value</b>
<b class="fc">&nbsp;                &quot;comment&quot; -&gt; comment = value</b>
<b class="fc">&nbsp;                &quot;account_status&quot; -&gt; accountStatus =</b>
<b class="pc">&nbsp;                    StringEnum.fromValue(value) ?: throw ParsingException(&quot;Unknown account status: $value&quot;)</b>
&nbsp;
<b class="fc">&nbsp;                &quot;married_to&quot; -&gt; marriedTo = value</b>
<b class="fc">&nbsp;                &quot;house&quot; -&gt; parseHouseColumn(columns[1])</b>
<b class="fc">&nbsp;                &quot;guild_membership&quot; -&gt; parseGuildColumn(columns[1])</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private fun CharacterBuilder.parseGuildColumn(valueColumn: Element) {
<b class="pc">&nbsp;        val guildName = valueColumn.selectFirst(&quot;a&quot;)?.text() ?: return</b>
<b class="fc">&nbsp;        val rankName = valueColumn.text().split(&quot;of the&quot;).first().trim()</b>
<b class="fc">&nbsp;        guild(rankName, guildName)</b>
&nbsp;    }
&nbsp;
&nbsp;    private fun CharacterBuilder.parseHouseColumn(valueColumn: Element) {
<b class="pc">&nbsp;        val match = houseRegexp.find(valueColumn.ownText()) ?: return</b>
<b class="pc">&nbsp;        val link = valueColumn.selectFirst(&quot;a&quot;)?.getLinkInformation() ?: return</b>
<b class="fc">&nbsp;        val (_, town, paidUntilStr) = match.groupValues</b>
<b class="fc">&nbsp;        addHouse(name = link.title,</b>
<b class="pc">&nbsp;            houseId = link.queryParams[&quot;houseid&quot;]?.first()?.toInt() ?: return,</b>
<b class="fc">&nbsp;            town = town,</b>
<b class="fc">&nbsp;            paidUntil = parseTibiaDate(paidUntilStr),</b>
<b class="pc">&nbsp;            world = link.queryParams[&quot;world&quot;]?.first() ?: return)</b>
&nbsp;    }
&nbsp;
&nbsp;    private fun CharacterBuilder.parseTitles(value: String) {
<b class="pc">&nbsp;        val match = titlesRegexp.find(value) ?: return</b>
<b class="fc">&nbsp;        val (_, currentTitle, unlockedTitlesStr) = match.groupValues</b>
<b class="fc">&nbsp;        title = if (currentTitle.contains(&quot;none&quot;, true)) null else currentTitle.trim()</b>
<b class="fc">&nbsp;        unlockedTitles = unlockedTitlesStr.toInt()</b>
&nbsp;    }
&nbsp;
&nbsp;    private fun CharacterBuilder.parseNameField(value: String) {
<b class="fc">&nbsp;        val match = deletedRegexp.matchEntire(value)</b>
<b class="fc">&nbsp;        name = if (match != null) {</b>
<b class="fc">&nbsp;            val (_, cleanName, deletionDateStr) = match.groupValues</b>
<b class="fc">&nbsp;            deletionDate = parseTibiaDateTime(deletionDateStr)</b>
<b class="fc">&nbsp;            cleanName</b>
&nbsp;        } else {
<b class="fc">&nbsp;            value</b>
&nbsp;        }
<b class="pc">&nbsp;        if (name.contains(tradedLabel)) {</b>
<b class="nc">&nbsp;            isRecentlyTraded = true</b>
<b class="nc">&nbsp;            name = name.remove(tradedLabel).trim()</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private fun CharacterBuilder.parseAccountBadges(rows: Elements) {
<b class="fc">&nbsp;        val row = rows[0]</b>
<b class="fc">&nbsp;        for (column: Element in row.select(&quot;td &gt; span&quot;)) {</b>
<b class="pc">&nbsp;            val popupSpan = column.selectFirst(&quot;span.HelperDivIndicator&quot;) ?: return</b>
<b class="fc">&nbsp;            val (title: String, popupContent: Document) = parsePopup(popupSpan.attr(&quot;onmouseover&quot;))</b>
<b class="fc">&nbsp;            val description = popupContent.text()</b>
<b class="pc">&nbsp;            val imageUrl = column.selectFirst(&quot;img&quot;)?.attr(&quot;src&quot;)</b>
<b class="pc">&nbsp;            addBadge(title, description, imageUrl ?: continue)</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private fun CharacterBuilder.parseAccountAchievements(rows: Elements) {
<b class="fc">&nbsp;        for (row: Element in rows) {</b>
<b class="fc">&nbsp;            val columns = row.select(&quot;td&quot;)</b>
<b class="fc">&nbsp;            if (columns.size != 2) continue</b>
<b class="fc">&nbsp;            val (gradeColumn, nameColumn) = columns</b>
<b class="fc">&nbsp;            val grade = gradeColumn.select(&quot;img&quot;).size</b>
<b class="fc">&nbsp;            val name = nameColumn.text()</b>
<b class="fc">&nbsp;            val isSecret = nameColumn.selectFirst(&quot;img&quot;) != null</b>
<b class="fc">&nbsp;            addAchievement(name, grade, isSecret)</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private fun CharacterBuilder.parseAccountInformation(rows: Elements) {
<b class="fc">&nbsp;        val valueMap = mutableMapOf&lt;String, String&gt;()</b>
<b class="fc">&nbsp;        for (row: Element in rows) {</b>
<b class="fc">&nbsp;            val columns = row.select(&quot;td&quot;)</b>
<b class="fc">&nbsp;            var (field, value) = columns.map { it.wholeText().clean() }</b>
<b class="fc">&nbsp;            field = field.replace(&quot; &quot;, &quot;_&quot;).remove(&quot;:&quot;).lowercase()</b>
<b class="fc">&nbsp;            if (field == &quot;position&quot;) {</b>
<b class="fc">&nbsp;                if (value.contains(&quot;tutor&quot;, true)) {</b>
<b class="fc">&nbsp;                    valueMap[&quot;stars&quot;] = columns[1].select(&quot;img&quot;).size.toString()</b>
&nbsp;                }
<b class="fc">&nbsp;                valueMap[field] = value</b>
<b class="fc">&nbsp;            } else valueMap[field] = value</b>
&nbsp;        }
<b class="pc">&nbsp;        accountInformation(created = parseTibiaDateTime(valueMap[&quot;created&quot;] ?: return),</b>
<b class="fc">&nbsp;            loyaltyTitle = valueMap[&quot;loyalty_title&quot;],</b>
<b class="fc">&nbsp;            position = valueMap[&quot;position&quot;],</b>
<b class="fc">&nbsp;            tutorStars = valueMap[&quot;stars&quot;]?.toInt())</b>
&nbsp;    }
&nbsp;
&nbsp;    private fun CharacterBuilder.parseCharacterDeaths(rows: Elements) {
<b class="fc">&nbsp;        for (row: Element in rows) {</b>
<b class="fc">&nbsp;            val columns = row.select(&quot;td&quot;)</b>
<b class="pc">&nbsp;            if (columns.size != 2) continue</b>
<b class="fc">&nbsp;            val (dateColumn, descriptionColumn) = columns</b>
<b class="fc">&nbsp;            val deathDateTime: Instant = parseTibiaDateTime(dateColumn.text())</b>
<b class="fc">&nbsp;            val deathMatch = deathsRegex.find(descriptionColumn.toString())</b>
<b class="pc">&nbsp;            var (_, levelStr, killersDesc) = deathMatch?.groupValues ?: Triple(&quot;&quot;,</b>
<b class="fc">&nbsp;                &quot;0&quot;,</b>
<b class="fc">&nbsp;                descriptionColumn.toString()).toList()</b>
<b class="fc">&nbsp;            var assistNameList: List&lt;String&gt; = mutableListOf()</b>
<b class="fc">&nbsp;            deathAssistsRegex.find(killersDesc)?.apply {</b>
<b class="fc">&nbsp;                killersDesc = this.groups[&quot;killers&quot;]?.value.orEmpty()</b>
<b class="pc">&nbsp;                val assistsDec = this.groups[&quot;assists&quot;]?.value ?: return</b>
<b class="fc">&nbsp;                assistNameList = linkSearch.findAll(assistsDec).map { it.value }.toList()</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            val killerNameList = killersDesc.splitList()</b>
<b class="fc">&nbsp;            val killerList = killerNameList.mapNotNull { parseKiller(it) }</b>
<b class="fc">&nbsp;            val assistsList = assistNameList.mapNotNull { parseKiller(it) }</b>
<b class="fc">&nbsp;            addDeath(deathDateTime, levelStr.toInt(), killerList, assistsList)</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private fun parseKiller(killerHtml: String): Killer? {
<b class="fc">&nbsp;        var name: String = killerHtml</b>
<b class="fc">&nbsp;        var isPlayer = false</b>
<b class="fc">&nbsp;        var isTraded = false</b>
<b class="fc">&nbsp;        var summon: String? = null</b>
<b class="fc">&nbsp;        if (killerHtml.contains(tradedLabel)) {</b>
<b class="fc">&nbsp;            name = killerHtml.clean().remove(tradedLabel).trim()</b>
<b class="fc">&nbsp;            isTraded = true</b>
<b class="fc">&nbsp;            isPlayer = true</b>
&nbsp;        }
<b class="fc">&nbsp;        if (killerHtml.contains(&quot;href&quot;)) {</b>
<b class="pc">&nbsp;            name = linkContent.find(killerHtml)?.groups?.get(1)?.value ?: return null</b>
<b class="fc">&nbsp;            isPlayer = true</b>
&nbsp;        }
<b class="fc">&nbsp;        deathSummon.find(name)?.apply {</b>
<b class="fc">&nbsp;            summon = groups[&quot;summon&quot;]!!.value.clean()</b>
<b class="fc">&nbsp;            name = groups[&quot;name&quot;]!!.value.clean()</b>
<b class="fc">&nbsp;        }</b>
&nbsp;
<b class="fc">&nbsp;        return Killer(name.clean(), isPlayer, summon, isTraded)</b>
&nbsp;    }
&nbsp;
&nbsp;    private fun CharacterBuilder.parseCharacters(rows: Elements) {
<b class="fc">&nbsp;        for (row: Element in rows.subList(1, rows.size)) {</b>
<b class="fc">&nbsp;            val columns = row.select(&quot;td&quot;)</b>
<b class="fc">&nbsp;            val (nameColumn, worldColumn, statusColumn, _) = columns</b>
<b class="fc">&nbsp;            var isTraded = false</b>
<b class="fc">&nbsp;            var name = nameColumn.text().splitList(&quot;.&quot;).last().clean()</b>
<b class="pc">&nbsp;            if (name.contains(tradedLabel, true)) {</b>
<b class="nc">&nbsp;                name = name.remove(tradedLabel).trim()</b>
<b class="nc">&nbsp;                isTraded = true</b>
&nbsp;            }
<b class="fc">&nbsp;            val isMain = nameColumn.selectFirst(&quot;img&quot;) != null</b>
<b class="fc">&nbsp;            val world = worldColumn.text().clean()</b>
<b class="fc">&nbsp;            val status = statusColumn.text().clean()</b>
<b class="fc">&nbsp;            val isOnline = status.contains(&quot;online&quot;)</b>
<b class="fc">&nbsp;            val isDeleted = status.contains(&quot;deleted&quot;)</b>
<b class="fc">&nbsp;            val position = if (status.contains(&quot;CipSoft Member&quot;)) &quot;CipSoft Member&quot; else null</b>
<b class="fc">&nbsp;            addCharacter(name, world, isMain, isOnline, isDeleted, isTraded, position)</b>
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-05-29 20:50</div>
</div>
</body>
</html>
