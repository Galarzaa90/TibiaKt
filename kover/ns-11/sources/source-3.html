


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>tibiakt-core Coverage Report > FormData</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope: tibiakt-core<span class="separator">|</span>    <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">com.galarzaa.tibiakt.core.utils</a>
</div>

<h1>Coverage Summary for Class: FormData (com.galarzaa.tibiakt.core.utils)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
<th class="coverageStat 
">
  Instruction, %
</th>
</tr>
<tr>
  <td class="name">FormData</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
    <td class="coverageStat"/>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (35/35)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright Â© 2024 Allan Galarza
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;
&nbsp;package com.galarzaa.tibiakt.core.utils
&nbsp;
&nbsp;import com.galarzaa.tibiakt.core.exceptions.ParsingException
&nbsp;import org.jsoup.Jsoup
&nbsp;import org.jsoup.nodes.Document
&nbsp;import org.jsoup.nodes.Element
&nbsp;import org.jsoup.nodes.TextNode
&nbsp;import org.jsoup.parser.Parser
&nbsp;import org.jsoup.select.Elements
&nbsp;import java.net.URL
&nbsp;
&nbsp;internal const val TABLE_SELECTOR = &quot;table.TableContent&quot;
&nbsp;
&nbsp;internal fun Element.boxContent(): Element =
&nbsp;    selectFirst(&quot;div.BoxContent&quot;) ?: throw ParsingException(&quot;BoxContent container not found&quot;)
&nbsp;
&nbsp;
&nbsp;internal fun Element.parseTables(contentTableSelector: String = TABLE_SELECTOR): Map&lt;String, Elements&gt; {
&nbsp;    val tables = select(&quot;div.TableContainer&quot;)
&nbsp;    val output = mutableMapOf&lt;String, Elements&gt;()
&nbsp;    for (table: Element in tables) {
&nbsp;        val captionContainer = table.selectFirst(&quot;div.CaptionContainer&quot;)
&nbsp;        val contentTable = table.selectFirst(contentTableSelector)
&nbsp;        val caption = captionContainer?.text() ?: throw ParsingException(&quot;table has no caption container&quot;)
&nbsp;        if (contentTable == null) continue
&nbsp;        val rows = contentTable.select(&quot;tr&quot;)
&nbsp;        output[caption] = rows
&nbsp;    }
&nbsp;    return output
&nbsp;}
&nbsp;
&nbsp;internal fun Element.parseTablesMap(contentSelector: String = &quot;div.TableContentContainer&quot;): Map&lt;String, Element&gt; {
&nbsp;    val tables = select(&quot;div.TableContainer&quot;)
&nbsp;    val output = mutableMapOf&lt;String, Element&gt;()
&nbsp;    for (table: Element in tables) {
&nbsp;        val caption: String =
&nbsp;            table.selectFirst(&quot;div.Text&quot;)?.cleanText() ?: throw ParsingException(&quot;table has no caption&quot;)
&nbsp;        val contentTable = table.selectFirst(contentSelector)
&nbsp;        output[caption] = contentTable ?: continue
&nbsp;    }
&nbsp;    return output
&nbsp;}
&nbsp;
&nbsp;/** Get a list of rows in the element. */
&nbsp;internal fun Element?.rows(): Elements = this?.select(&quot;tr&quot;) ?: Elements()
&nbsp;
&nbsp;/** Get a list of cells found in the elmenet. */
&nbsp;internal fun Element?.cells(): Elements = this?.select(&quot;td&quot;) ?: Elements()
&nbsp;
&nbsp;/** Get a list of the text contained in all cells in the element.*/
&nbsp;internal fun Element.cellsText(): List&lt;String&gt; = cells().map { it.cleanText() }
&nbsp;
&nbsp;/** Get the text contained in an element, cleaned out of extraneous characters. */
&nbsp;internal fun Element.cleanText() = text().clean()
&nbsp;internal fun TextNode.cleanText() = text().clean()
&nbsp;
&nbsp;/** Get the text contained in a list of element, cleaned out of extraneous characters. */
&nbsp;internal fun Elements.cleanText() = text().clean()
&nbsp;
&nbsp;/** Get the text contained in an element, cleaned out of extraneous characters. */
&nbsp;internal fun Element.wholeCleanText() = wholeText().clean()
&nbsp;
&nbsp;
&nbsp;/** Replace all br tags in an element with line jumps. */
&nbsp;internal fun Element.replaceBrs() = apply {
&nbsp;    select(&quot;br&quot;).forEach { it.replaceWith(TextNode(&quot;\n&quot;)) }
&nbsp;}
&nbsp;
&nbsp;/** Replace all br tags in an array of elements with line jumps. */
&nbsp;internal fun ArrayList&lt;Element&gt;.replaceBr() = forEach { it.replaceBrs() }
&nbsp;
&nbsp;/** Get all the field&#39;s values and available options of a form element.
&nbsp; *
&nbsp; * @receiver An element with the form tag.
&nbsp; */
&nbsp;internal fun Element.formData(): FormData {
&nbsp;    require(this.tagName().lowercase() == &quot;form&quot;) {
&nbsp;        &quot;expected element with &#39;form&#39; tag, got element with &#39;${this.tagName()}&#39; tag&quot;
&nbsp;    }
&nbsp;    val data = mutableMapOf&lt;String, String&gt;()
&nbsp;    val dataMultiple = mutableMapOf&lt;String, MutableList&lt;String&gt;&gt;()
&nbsp;    val availableOptions = mutableMapOf&lt;String, MutableList&lt;String&gt;&gt;()
&nbsp;    select(&quot;input[type=text], input[type=hidden]&quot;).forEach { data[it.attr(&quot;name&quot;)] = it.attr(&quot;value&quot;) }
&nbsp;    select(&quot;select&quot;).forEach {
&nbsp;        it.select(&quot;option&quot;).forEach { opt -&gt;
&nbsp;            val value = opt.attr(&quot;value&quot;)
&nbsp;            val name = it.attr(&quot;name&quot;)
&nbsp;            availableOptions.getOrPut(name) { mutableListOf() }.add(value)
&nbsp;            if (opt.hasAttr(&quot;selected&quot;)) data[name] = value
&nbsp;        }
&nbsp;    }
&nbsp;    select(&quot;input[type=checkbox]&quot;).forEach {
&nbsp;        val name = it.attr(&quot;name&quot;)
&nbsp;        val value = it.attr(&quot;value&quot;)
&nbsp;        availableOptions.getOrPut(name) { mutableListOf() }.add(value)
&nbsp;        if (it.hasAttr(&quot;checked&quot;)) dataMultiple.getOrPut(name) { mutableListOf() }.add(value)
&nbsp;    }
&nbsp;    select(&quot;input[type=radio]&quot;).forEach {
&nbsp;        val name = it.attr(&quot;name&quot;)
&nbsp;        val value = it.attr(&quot;value&quot;)
&nbsp;        availableOptions.getOrPut(name) { mutableListOf() }.add(value)
&nbsp;        if (it.hasAttr(&quot;checked&quot;)) data[name] = value
&nbsp;    }
&nbsp;    return FormData(data, dataMultiple, availableOptions, action = attr(&quot;action&quot;), method = attr(&quot;method&quot;))
&nbsp;}
&nbsp;
&nbsp;/**
&nbsp; * Contains the data extracted from a form.
&nbsp; * @property values Mapping of form fields to their selected value.
&nbsp; * @property valuesMultiple Mapping of form fields that might have multiple values.
&nbsp; * @property availableOptions Mapping of the available options for selection in the form.
&nbsp; * @property action Where the form would be submitted to.
&nbsp; * @property method The HTTP method used
&nbsp; */
&nbsp;internal data class FormData(
<b class="fc">&nbsp;    val values: Map&lt;String, String&gt; = emptyMap(),</b>
<b class="fc">&nbsp;    val valuesMultiple: Map&lt;String, List&lt;String&gt;&gt; = emptyMap(),</b>
<b class="fc">&nbsp;    val availableOptions: Map&lt;String, List&lt;String&gt;&gt; = emptyMap(),</b>
<b class="fc">&nbsp;    val action: String? = null,</b>
<b class="fc">&nbsp;    val method: String? = null,</b>
&nbsp;)
&nbsp;
&nbsp;private val pageRegex = Regex(&quot;&quot;&quot;(?:page|pagenumber)=(\d+)&quot;&quot;&quot;)
&nbsp;private val resultsRegex = Regex(&quot;&quot;&quot;Results: ([\d,]+)&quot;&quot;&quot;)
&nbsp;
&nbsp;/** Parse the pagination block present in many Tibia.com sections. */
&nbsp;internal fun Element.parsePagination(): PaginationData {
&nbsp;    val (pagesDiv, resultsDiv) = select(&quot;small &gt; div&quot;)
&nbsp;    val currentPageLink = pagesDiv.selectFirst(&quot;.CurrentPageLink&quot;)
&nbsp;    val pageLinks = pagesDiv.select(&quot;.PageLink&quot;)
&nbsp;    val firstOrLastPages = pagesDiv.select(&quot;.FirstOrLastElement&quot;)
&nbsp;    val totalPages = if (firstOrLastPages.isNotEmpty()) {
&nbsp;        val lastPageLink = firstOrLastPages.last()?.selectFirst(&quot;a&quot;)
&nbsp;        if (lastPageLink != null) {
&nbsp;            pageRegex.find(lastPageLink.attr(&quot;href&quot;))?.let {
&nbsp;                it.groups[1]!!.value.toInt()
&nbsp;            } ?: throw ParsingException(&quot;Could not parse pagination info&quot;)
&nbsp;        } else {
&nbsp;            pageLinks[pageLinks.size - 2].text().toInt()
&nbsp;        }
&nbsp;    } else {
&nbsp;        pageLinks.last()?.text()?.toInt() ?: throw ParsingException(&quot;could not find last page link&quot;)
&nbsp;    }
&nbsp;    val page = try {
&nbsp;        currentPageLink?.text()?.toInt() ?: totalPages
&nbsp;    } catch (nfe: NumberFormatException) {
&nbsp;        if (currentPageLink?.text()?.contains(&quot;First&quot;) == true) 1
&nbsp;        else totalPages
&nbsp;    }
&nbsp;    val resultsCount: Int = resultsRegex.find(resultsDiv.text())?.let {
&nbsp;        it.groups[1]!!.value.parseInteger()
&nbsp;    } ?: 0
&nbsp;    return PaginationData(page, totalPages, resultsCount)
&nbsp;}
&nbsp;
&nbsp;/**
&nbsp; * Container for pagination information.
&nbsp; */
&nbsp;internal data class PaginationData(val currentPage: Int, val totalPages: Int, val resultsCount: Int) {
&nbsp;    companion object {
&nbsp;        fun default() = PaginationData(1, 1, 0)
&nbsp;    }
&nbsp;}
&nbsp;
&nbsp;internal fun parsePopup(content: String): Pair&lt;String, Document&gt; {
&nbsp;    val parts = content.split(&quot;,&quot;, limit = 3)
&nbsp;    val title = parts[1].replace(&quot;&#39;&quot;, &quot;&quot;).trim()
&nbsp;    val html = parts[parts.size - 1].replace(&quot;\\&#39;&quot;, &quot;\&quot;&quot;).replace(&quot;&#39;&quot;, &quot;&quot;).replace(&quot;,);&quot;, &quot;&quot;).replace(&quot;, );&quot;, &quot;&quot;).trim()
&nbsp;    val parsedHtml = Jsoup.parse(html, &quot;&quot;, Parser.xmlParser())
&nbsp;    return title to parsedHtml
&nbsp;}
&nbsp;
&nbsp;private val queryStringRegex = Regex(&quot;([^&amp;=]+)=([^&amp;]*)&quot;)
&nbsp;internal fun Element.getLinkInformation(): LinkInformation? {
&nbsp;    if (this.tagName() != &quot;a&quot;) return null
&nbsp;    return LinkInformation(this.text(), this.attr(&quot;href&quot;))
&nbsp;}
&nbsp;
&nbsp;internal data class LinkInformation(val title: String, val targetUrl: URL) {
&nbsp;    val queryParams
&nbsp;        get() = targetUrl.queryParams()
&nbsp;
&nbsp;    constructor(title: String, targetUrl: String) : this(title, URL(targetUrl))
&nbsp;
&nbsp;}
&nbsp;
&nbsp;internal fun URL.queryParams(): HashMap&lt;String, MutableList&lt;String&gt;&gt; {
&nbsp;    val matches = queryStringRegex.findAll(this.query)
&nbsp;    val map: HashMap&lt;String, MutableList&lt;String&gt;&gt; = hashMapOf()
&nbsp;    for (match: MatchResult in matches) {
&nbsp;        val (_, name, value) = match.groupValues
&nbsp;        map.getOrPut(name) { mutableListOf() }.add(value)
&nbsp;    }
&nbsp;    return map
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-05-25 16:14</div>
</div>
</body>
</html>
